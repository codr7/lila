(add-method (ensure-generic-function 'foo)
            (make-instance 'standard-method
                            :qualifiers '()
                            :lambda-list '(object)
                            :specializers (list (find-class 't))
                            :function (lambda (&rest args)
                                        (format t "Method called: ~a~%" args))))
* add-lisp-method
** use in let-fun/macro/lisp-macro
** return (values gen imp)
* fix fun ids
** bind method as foo[X Y]
** bind separate generic fun instance foo
* fib_rec
** add fun op
*** push fun if nil id
* --
* add types to readme
** add type-of/is-a funs
* add support for unnamed args
** leave values on stack
** don't include in lisp method arg list
* add list literals
** (...)
* add lambdas
** fun with nil id & lambda imp
* add fun refs
** &foo
* add macro refs
** &bar
** generate (lambda (x y) (foo x y))
* add Time type
** use local-time
** add now/today funs
** add *time-format*
* add ordered set
** new-set {'foo 'bar}
** new-map {'foo 1 'bar 2}
** new-id-map {foo 1 bar 2}
* add quote support
** trigger on ' in reader
** call (quote val)
*** stored as (cons 'quote val)
** add quote type
** adapt list methods to handle quotes
* add check macro
** check {= foo 42}
* add test/suite.lila
* add lisp read-macro
** add do-lisp op
** add read macros
** trigger in read-id
** single form
** do-lisp (+ 1 2)
* add recall op
** optional fun arg
*** call self if arg is _
** (return ((lisp-id f) pos ...))
* add -compile switch
** dump lisp code
+* add do-lila reader macro
** read vals until next char is #\)
* ---
* add lila-thread plugin
** plugin.lisp/(link)
** use sbcl threads
** add thread/chan types
